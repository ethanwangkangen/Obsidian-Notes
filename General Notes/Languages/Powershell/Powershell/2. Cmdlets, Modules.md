# Cmdlset
- Single-feature command that manipulates objects 
- Verb-Noun structure

# PowerShell modules
A module is just a folder with metadata that PowerShell knows how to import.
- **Script module**: `MyModule.psm1` (PowerShell code).
- **Binary module**: `MyModule.dll` (compiled .NET cmdlets).
- **Manifest**: `MyModule.psd1` (metadata: version, author, what to export, dependencies via `RequiredModules`, etc.).
- Optional extras: **types** (`.ps1xml`), **format** files, nested modules, helpers.

PowerShell searches for modules in folders listed in **`$env:PSModulePath`** (semicolon-separated list of directories).

Example
- PowerSploit.psd1 https://github.com/PowerShellMafia/PowerSploit/blob/master/PowerSploit.psd1
	- `.psd1`- PowerShell data file -> is a Module manifest file
		- Can find things like reference to module processed, GUID, version numbers, author of module, modules and cmdlets included, metadata..
- PowerSploit.psm1
	- `.psm1` - PowerShell script module
		- Script containing PowerShell code (meat of a module)
		- In this case contains `Get-ChildItem $PSScriptRoot | ? { $_.PSIsContainer -and !('Tests','docs' -contains $_.Name) } | % { Import-Module $_.FullName -DisableNameChecking }

## Using the module
- Must consider if chosen module and scripts are already on host
- `Get-Module -ListAvailable`
	- See modules we have **installed** but **not loaded**
		- Scans directories in the env var `$env:PSModulePath
			- `echo $env:PSModulePath
				- Actually don't even need the echo
- `Get-Module`
	- See what modules are **loaded**
- `Get-Command -Module <modulename>`
	- See what commands come with the module

## Importing/loading modules
Loading/loading
- make a module's exported commands available in **this session**
	- `Import-Module .\PowerSploit.psd1`
- "Adding to a session"
	- Same idea; for **remote**, can import into the remote or import from remote using implicit remoting
- Adds module path into `$env:PSModulePath`

### Execution policy
- `Get-ExecutionPolicy`
	- Might show `restricted` -> cannot run script
	- Solve: `Set-ExecutionPolicy Undefined`
		- Make sure to change it back to `restricted` when done
			- Or, set `-scope Process`

# PowerShell Gallery
- Repository that contains PS scripts, modules etc.
- `PowerShellGet` module
	- To access the repo
- `Get-Command -Module PowershellGet`
	- See commands that PowerShellGet provides
- `Find-Module`
	- Command from PSGet to find module inside repo
- `Install-Module`
	- Command from PSGet to install module inside repo
- Let's start to use piping
	- `find-module -name admintoolbox | install-module`

## Important tools
- [AdminToolbox](https://www.powershellgallery.com/packages/AdminToolbox/11.0.8): AdminToolbox is a collection of helpful modules that allow system administrators to perform any number of actions dealing with things like Active Directory, Exchange, Network management, file and storage issues, and more.
    
- [ActiveDirectory](https://learn.microsoft.com/en-us/powershell/module/activedirectory/?view=windowsserver2022-ps): This module is a collection of local and remote administration tools for all things Active Directory. We can manage users, groups, permissions, and much more with it.
    
- [Empire / Situational Awareness](https://github.com/BC-SECURITY/Empire/tree/master/empire/server/data/module_source/situational_awareness): Is a collection of PowerShell modules and scripts that can provide us with situational awareness on a host and the domain they are apart of. This project is being maintained by [BC Security](https://github.com/BC-SECURITY) as a part of their Empire Framework.
    
- [Inveigh](https://github.com/Kevin-Robertson/Inveigh): Inveigh is a tool built to perform network spoofing and Man-in-the-middle attacks.
    
- [BloodHound / SharpHound](https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors): Bloodhound/Sharphound allows us to visually map out an Active Directory Environment using graphical analysis tools and data collectors written in C# and PowerShell.