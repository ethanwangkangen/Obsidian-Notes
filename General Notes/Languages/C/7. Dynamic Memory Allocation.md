Previously looked at how memory can be allocated in the stack. eg. 
```c
int arr[5] = {1,2,3,4,5};
int x = 6;
```

But what if memory needed not known at compile time?

```c
#include <stdlib.h>

void* malloc(size_t size);
// Allocates `size` bytes of **uninitialised** memory.
// Returns a pointer to the beginning of the block or `NULL` if it fails
// eg.
int* arr = malloc(5 * sizeof(int)); // allocates space for 5 integers


void* calloc(size_t num, size_t size);`
// Allocates memory for an array of `num` elements, each of `size` bytes. 
// Sets all bits to zero
//eg.
int* arr = calloc(5, sizeof(int)); // allocates and zeroes 5 ints`


void* realloc(void* ptr, size_t new_size);`
//eg.
arr = realloc(arr, 10 * sizeof(int)); // resize to hold 10 ints`

void free(void* ptr);`
//eg. 
free(arr);
```

Observe that malloc/calloc return void pointers, which are then implicitly cast into the respective int pointers/whatever data type pointer.

However, in C++, need to do this explicitly.
```c
int* arr = (int*)malloc(5 * sizeof(int)); // Required in C++`
```

Also note the need to \#include <stdlib.h>
