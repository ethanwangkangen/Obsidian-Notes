
# Variables
```python
# Basic variables
i = 1337             # int (unbounded)
x = 3.14             # float
s = "Host: target"   # str = Unicode text
b = b"GET / HTTP/1.1\r\n"  # bytes = raw data (protocols, files)

# Conversions
len(s)               # characters
len(b)               # bytes
b.decode("utf-8")    # bytes -> str
"hi".encode()        # str -> bytes
int("ff", 16)        # base conversion -> 255
```

```python
lst = [80, 443, 445]                    # list (ordered, mutable)
tup = ("10.10.10.10", 80)               # tuple (ordered, immutable)
dct = {"Host": "target", "UA": "Recon"} # dict (key->value)
st  = {"admin", "login"}                # set (unique items)
```

# Lists

```python
# Basics
ports = [80, 443, 445]
ports[0]          # index → 80
ports[-1]         # last → 445
ports[0:2]        # slice → [80, 443]
len(ports)        # 3
80 in ports       # membership → True

# Mutating
ports.append(8080)                # add to end
ports.extend([22, 25])            # add many
ports.insert(1, 81)               # insert at index
ports.remove(81)                  # remove first matching value
p = ports.pop()                   # remove & return last item
ports.clear()                     # empty list

# Sorting
nums = [5, 1, 10]
nums.sort()                       # in-place ascending
nums.sort(reverse=True)           # in-place descending
sorted_nums = sorted(nums)        # new list, original unchanged

rows = [{"code":403}, {"code":200}]
rows.sort(key=lambda r: r["code"])  # custom key

# Others
ports.count(80)        # number of occurrences
ports.index(443)       # first index of value
ports.copy()           # shallow copy
[x*2 for x in [1,2,3]] # list comprehension
```

# Tuples

```python
# Basics
t = ("target.com", 443)
t[0], t[1]

single = (42,)      # note trailing comma makes it a tuple

# Packing, unpacking
host, port = t      # unpacking
a, b, *rest = (1,2,3,4)  # starred unpacking

# Methods
t.count(443)
t.index(443)
```
# Dicts

```python
# Basics
h = {"Host": "target.com", "User-Agent": "ReconBot"}
h["Host"]                   # lookup (KeyError if missing)
h.get("Server")             # None if missing (or provide default)
h.get("Server", "unknown")  # default
"Host" in h                 # membership checks keys

# Updating
h["Accept"] = "*/*"            # set/add
h.update({"X-Trace": "1"})     # merge
h.setdefault("Server", "nginx")# set only if absent

# Removing and iterating
h.pop("X-Trace", None)     # remove key, return value/default
k, v = h.popitem()         # remove & return an arbitrary pair (LIFO in CPython)
h.keys()                   # view of keys
h.values()                 # view of values
h.items()                  # (key, value) pairs
for k, v in h.items(): ...

# Comprehension
paths = ["admin", "login"]
status = [403, 200]
m = {p: s for p, s in zip(paths, status)}  # {'admin':403, 'login':200}

# Extras from collections
from collections import defaultdict, Counter
d = defaultdict(list)
d["errors"].append("timeout")
Counter([200,200,403])   # counts occurrences per value
```

# Sets
```python
seen = {"admin", "login"}
"admin" in seen     # True
len(seen)

# Add/remove
seen.add("api")
seen.update(["health", "metrics"])  # add many
seen.remove("api")   # KeyError if not present
seen.discard("api")  # safe remove (no error if absent)
item = seen.pop()    # remove & return an arbitrary element
seen.clear()

# Set algebra
a = {"admin","login","api"}
b = {"login","metrics"}

a | b    # union → {'admin','login','api','metrics'}
a & b    # intersection → {'login'}
a - b    # difference → {'admin','api'}
a ^ b    # symmetric difference → {'admin','api','metrics'}

a.issubset(b), a.issuperset(b)

# Comprehension
{x for x in [1,2,2,3] if x % 2 == 1}   # {1,3}
```


# Useful tools
## Comprehension 
```python
# 4 types: based on type of bracket used

# List
[new_item  for item in iterable  if condition]

# Set
{func(x) for x in data if predicate(x)}

# Dict
{key_expr: value_expr  for item in iterable  if condition}

# Generator (produces lazy iterator, no list allocated)
(expr for item in iterable if condition)
# x = list(generator)

#eg.
open_ports = [p for p in range(1, 1025) if p % 2 == 0] # range(..) gives an iterable
hostmap = {ip: "up" for ip in ["10.0.0.1", "10.0.0.2"]}
```

- Can also add on conditional
	- `[new_item fo x in iterable if condition else y]

What is an iterable?
- Implements `__iter__()` that returns an iterator
- Iterator is object with `__next__()` 
- Examples
	- Sequences: list, tuple, str, bytes, bytearray, range
	- Mappings & views: dict (iterates keys), d.keys(), d.values(), d.items()
	- Sets: set, frozenset
	- Files: file objects iterate over lines
	- Generators: functions with yield, generator expressions
	- Standard-library iterators: from itertools (e.g., chain, count, islice

## Enumerate
- Adds running index to any iterable
	- When you need item and its position
	- Better than looping with manual counter

```python
# enumerate(iterable, start=0)

paths = ["admin","login","api"]
for i, p in enumerate(paths):
    print(i, p)         # 0 admin / 1 login / 2 api

for i, p in enumerate(paths, start=1):
    print(i, p)         # 1 admin / 2 login / 3 api

list(enumerate(paths))  # [(0, "admin), (1, "login"), (2, "api")]
```

## Zip
- Walks iterables in lockstep, yielding **tuples** of corresponding elements
- Stops at **shortest** iterable by default
- eg.
```python
paths  = ["admin","login","api"]
codes  = [403, 200, 401]
sizes  = [512, 128, 256]

for tup in zip(paths, codes, sizes):
    print(tup)
    
# ('admin', 403, 512)
# ('login', 200, 128)
# ('api', 401, 256)
    
dict(zip(paths, codes))  # {'admin':403, 'login':200, 'api':401}
```

Check equal lengths
- `zip(list1, list2, strict=True)`
	- `strict=True`: ValueError if lengths differ