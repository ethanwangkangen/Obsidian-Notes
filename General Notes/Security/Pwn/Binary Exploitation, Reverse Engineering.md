# Checksec
- checksec --file ./vuln_exec

| Feature | Description                                                                |                                                                                                                                                                   |
| ------- | -------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| RELRO   | Protection of GOT (part of the ELF structure). Full is best.               | Canary is placed before return address. If overwritten, it triggers a crash before attacker can hijack control flow. If canary can be leaked, it can be bypassed. |
| Canary  | Stack canary is enabled (protects return address from buffer overflow).    | Marks stack as non-executable. Prevents attacker from jumping to shellcode placed in buffer. Forces attacker to use ROP or ret2libc instead.                      |
| NX(DEP) | Non-executable stack — prevents shellcode on stack from running.           | Makes binary load at random address each time (ASLR). Prevents attacker from knowing exact address of functions or gadgets in the binary. Makes ROP harder        |
| PIE     | Position Independent Executable — enables ASLR for the binary itself.      | Hardens Global Offset Table (GOT). With Full RELRO, GOT is read-only — attacker can’t overwrite it to hijack function pointers.                                   |
| Fortify | Compile-time hardened standard functions (like `strcpy` → `__strcpy_chk`). | Adds checks for dangerous functions like strcpy, sprintf. Less common to directly bypass, but can help spot unsafe functions.                                     |
|         |                                                                            |                                                                                                                                                                   |

# Buffer Overflows on the stack
See [[2. Stack layout]].
- We start with a buffer that can be written to without checks on limit
	- eg. gets(), strcpy()..

From here, we can possibly overwrite the Return Pointer, such that when this function returns, it returns to another memory address than what it should.
- First level, if we have a win() function, then just go to that address.
	- If not stripped, can find with info functions in gdb. If not can just look for the functions in Ghidra too.
- Can also override variables if need be.
	- eg. Stack canary (if able to leak it)
- What if there is no win() function?
	- Shellcode injection

# Shellcode injection
Since there's not win() function, we can winsert our own assembly code into the stack, and then change the Return Pointer to point to that stack address.
- Requires executable stack.

# Return Oriented Programming
Recap on [[Ghidra, Assembly]]
