2 broad types
- Temporal
- Spatial

# Stack-based attacks and other spatial attacks

## Stack-based buffer overflow (spatial)

```c
void vulnerable(char* input) {
    char buf[8];
    strcpy(buf, input); // no bounds checking!
}
```

For the stack layout, see [[2. Stack layout]]

Basic stack:

| Higher address    |                                          |                                                                                |
| ----------------- | ---------------------------------------- | ------------------------------------------------------------------------------ |
|                   | (optional) arguments passed to fn        | *for 64-bit architecture, only after firs 6 args. First 6 passed via registers |
|                   | **Return Address**                       |                                                                                |
|                   | Old base pointer                         | Base pointer                                                                   |
|                   | **... Local variables (buffer is here)** |                                                                                |
|                   |                                          | Stack pointer                                                                  |
| **Lower address** |                                          | <br>                                                                           |
|                   |                                          |                                                                                |

Important points
- Stack grows downwards. 
- When function calls another function, new stack frame is placed BELOW
	- Arguments for callee (new function) are pushed (added below)
	- Call instruction -> return address pushed, which points back to caller (old function)
	- Callee prologue
		- `push ebp` -> save caller's EBP
		- `mov ebp, esp` -> set base pointer for callee frame
		- `sub esp, N` -> allocate callee locals



**New stack:**

| Higher address          |                                          |                                                                                |
| ----------------------- | ---------------------------------------- | ------------------------------------------------------------------------------ |
|                         | (optional) arguments passed to fn        | *for 64-bit architecture, only after firs 6 args. First 6 passed via registers |
|                         | **Return Address**                       |                                                                                |
|                         | Old base pointer                         | ~~Base pointer~~ (caller's BP)                                                 |
|                         | **... Local variables (buffer is here)** |                                                                                |
|                         |                                          | ~~Stack pointer~~ (moves down before becoming new BP)                          |
| *New frame starts here* | Arguments for new function               |                                                                                |
|                         | Return Address                           | (Want to override this)                                                        |
|                         | Caller's base pointer                    | Base pointer                                                                   |
|                         | Local variables                          | (Buffer here. Write until it overrides Return Address above)<br>               |
| **Lower address**       |                                          | Stack pointer                                                                  |

- Idea is
	- Have a buffer, in this case buf
	- Have a function that doesn't do bounds check.
	- Eventually want to overwrite the return address of the function that contains the buffer in its scope
		- ie. For return address of the stack frame of that function
- Caller epilogue (teardown)
	- `mov rsp, rbp` -> move stack pointer down to current base pointer
	- `pop rbp` -> rsp is currently pointing to caller bp, restore rbp to this and move stack pointer up. rsp now points to Return address.
	- `ret` 

## Code reuse: ret2libc

We know how to overflow and modify the Return Address (RIP).
Now, overwrite it to make a system call.

| Higher address    |                         |                |               |
| ----------------- | ----------------------- | -------------- | ------------- |
|                   |                         | <- &'bin/sh'   |               |
|                   |                         | <- Fake return |               |
|                   | **Return Address**      | <- &system     |               |
|                   | Old base pointer        |                | Base pointer  |
|                   | **... Local variables** |                |               |
|                   |                         |                | Stack pointer |
| **Lower address** |                         |                | <br>          |

Explanation:
- What we did was essentially simulate the system() function as a CALLEE stack to the vuln() function
	- ie. set up a **fake stack frame BEFORE** vuln()'s stack frame
	- essentially, pretending like system() is the caller of vuln(), such that when vuln, returns, system() executes, and has the correct stack frame set up for itself
	- at the end of vuln(), RSP gets moved to RBP and then above it(see caller epilogue above), then `ret` pops it so RIP moves to instrutions for *&system*, then the arguments to system() are taken from above RSP.
- Once the vuln() returns, CPU pops the return address, instruction pointer jumps to system()


## Code injection:  Shellcode Injection
- Similar idea
- Inject shellcode directly into the stack, right above the return address
	- Then overwrite return address to where the shellcode is
- Issue: not sure where exactly this starts? 
- Solution: Inject nopslide first before shellcode


Difference:
- Code injection
	- Memory exploit that hijacks control to jump to attacker's data payload
	- Requirements:
		- Write attack payload in memory
		- Have attack payload be executable
		- Divert control flow to payload
- Code reuse
	- Memory exploit that hijacks control to jump to attacker's controlled code access
	- Requirements
		- Write attack payload in memory
		- Divert control 




## Format String vulneratbility

- From above we can see that arguments to functions are passed on the stack as well
	- For x64, only the 6th argument onwards are on the stack, first 5 in registers
- So for functions like printf(), if we call
	- `printf("%08x,... ")`
	- It will look for those arguments in the stack. If they don't exist, then will start to print random values from the stack, and possibly leak other values
	- printf just assumes everything above it are the arguments passed to it.
- Format specifiers
	- `%d` - print as number
	- `%p` - print as pointer
	- `%c` - print as character
	- `%s` - read from address provided and print bytes until NULL byte reaches
		- interprets as a pointer, dereferences the pointer
	- `%x` - print as integer
		- no dereferencing. may reveal raw stack words or pointers as numbers
	- `%n` - write number of bytes already printed in address provided
	- `<n>$` - access n'th positional argument with respect to printf
		- eg. %5$p


## Integer Overflow

Unsigned integers
- Wrap modulo 2^n, where n is number of value bits
	- eg. unsigned int: (uint_max+ 1) == 0
Signed integers
- Overflow is undefined behaviour
- Assume wrap around too


# Heap overflows

Heap memory
- Stored in a linked list
- The chunk of memory itself keeps track of what the next chunk is
- If can overwrite -> can overwrite the next chunk

For data oriented attacks
- Don't need to write to any control data, just manipulate non-control data
- None of the 3 requirements for code injection/reuse attacks apply anymore

# Bad Casting

C++: Class Subtyping
```c
class Base{
  // members...
  // member function
}

class Derived : public Base {
	// members...
	// member function
}

Derived* d = new Derived();
```

How memory works:
- The layout of the derived object contains the base object
- \[\[Base object] Derived object]
	- d points to the start of the Base object
- because every variable/method in the Base class is accessble in Derived

C++ implementation
- Upcasting with Single inheritance
	- Upcasting always safe in C++, ie. can cast Derived (child) class to Base (parent) class, ie D to B

```c
Derived* d = new Derived()

// Implicit cast
Base* b1 = (Base *) &d;

// Explicit caast
Base* b2 = static_cast<Base*> (&d);
```

- now d, b1, b2 all pointing to the start of the Base object in memory

Multiple inheritance
```c
class B1 {...}; class B2 {...};
class Derived: public B1, public B2 {...}; // Derived inherits from both B1 and B2

Derived* d = new Derived();

// Implicit cast
B1* b1 = (B1 *)&d;
B2* b2 = (B2 *)&d; // Pointer moves! from start of d to b2. Should not have anything from b1.

// Explicit cast
B2* h = static_cast<B2*> (&d);
```

\[\[B1]\[B2] Derived object]
- b1, d point to start of b1
- b2, h point to start of b2

Downcasting also allowed.
```c
class B1 {...}; class B2 {...};
class Derived: public B1, public B2 {...}; // Derived inherits from both B1 and B2

Derived* d = new Derived();
foo(d);

int foo (B2* b) {
	Derived* d = static_cast <Derived*>(b); // downcast (safe here because d WAS actually a Derived object)
}

```

\[\[B1]\[B2] Derived object]
- pointer goes from start of B2 to start of B1.

This is not always safe!
- it's assuming that b did in fact point to a Derived object, but may not be the case.
- ie. it's ONLY safe if i use foo() on an actual Derived object

**Unsafe downcast example**
```c
class Base {int x};
class Derived : public Base {int y};

int foo (B2* b) { // downcast
	Derived* d = static_cast <Derived*>(b); 
}
int main() {
	Base *b = new Base();
	foo(b); // b is now of type Derived
	d -> y = 0; // changes memory that it shouldn't have access to
}
```

b is only a base object. 
- it doesn't actually have a y allocation (not in scope), but program allows it to modify memory below x.

**Worse, badcasting with multiple inheritance**
```c

class B1{...}, class B2 {int y};
class Derived: public B1, public B2 {...}

B1* = new B1();

// Unsafe downcast
Derived* d = (Derived*) b1;
B2* b2 = (B2*)&d;

B2 -> y = 0
```

\[\[B1]\[B2] Derived object]
- Originally, just have a B1 object. No memory allocated for B2 etc.
- the **b2 pointer moves down** from B1 to B2. (BUT THERE'S ACTUALLY NO MEMORY ALLOCATED THERE)
- so again, b2-> writes to some unknown memory that should not be allowed

So the key ideas:
- single inheritance: downcasting can be dangerous, may allow access to regions of memory that it should not have
- multiple inheritance: base pointer can move up/down due to unsafe downcasting, again allowing memory writing to unsafe places

