# Basic Fuzzing

## Directory Fuzzing
- `ffuf -w /opt/useful/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ`
	- `-w`: wordlist
	- `:FFUZ`: assign the wordlist to the keyword FFUZ
	- `-u`: the URL
	- `/FFUZ`: the plce we want to fuzz

## Page fuzzing

### Extension fuzzing
- eg. want to find out what extensions the pages on the server uses
- `ffuf -w /opt/useful/seclists/Discovery/Web-Content/web-extensions.txt:FUZZ -u http://SERVER_IP:PORT/blog/indexFUZZ`

Now that we know what extensions the pages use, can fuzz for page
### Page fuzzing
- `ffuf -w /opt/useful/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/blog/FUZZ.php`
	- .php since we already found the extension from extnesion fuzzing

## Recursive Fuzzing
- Above, we did
	- Directory fuzzing -> Search for files within these directories
- Can **automate** this with recursive fuzzing
- `ffuf -w /opt/useful/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ -recursion -recursion-depth 1 -e .php -v`
	- `-recursion`: recursive fuzzing
	- `-recursion-depth 1`: only main directories and direct subdirectories
	- `-e`: extension chosen

# DNS Records
Previously was doing **subdirectory** enumeration, now do **subdomain** enumeration

## Subdomain enumeration
- eg. `*website.com
- `ffuf -w /opt/useful/seclists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u https://FUZZ.inlanefreight.com/
	- Note: does not work if have no public DNS

## Vhost fuzzing
- Vhosts - "subdomain" that is served on **same server and IP**
- Vhosts may or may not have public DNS records
	- Resolved via the **host** header in HTTP request
	- Hence, when we fuzz, we want to fuzz this header
- `ffuf -w /opt/useful/seclists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u http://academy.htb:PORT/ -H 'Host: FUZZ.academy.htb'
	- Visiting the same sight, just changing the `HOST` part of the HTTP request only

## Filtering results
- Can match/filtter out
	- HTTP code
	- Response size
	- Amount of words
- Can view options with `ffuf -h`
- MATCHER OPTIONS:
	- mc             Match HTTP status codes, or "all" for everything. (default: 200,204,301,302,307,401,403)
	- ml              Match amount of lines in response
	- mr              Match regexp
	- ms              Match HTTP response size
	- mw             Match amount of words in response
- FILTER OPTIONS:
	- fc             Filter HTTP status codes from response. Comma separated list of codes and ranges
	- fl              Filter by amount of lines in response. Comma separated list of line counts and ranges
	- fr              Filter regexp
	- fs              Filter HTTP response size. Comma separated list of sizes and ranges
	- fw             Filter by amount of words in response. Comma separated list of word counts and ranges
- `ffuf -w /opt/useful/seclists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u http://academy.htb:PORT/ -H 'Host: FUZZ.academy.htb' -fs 900
	- Filter out responses with status code 900

# Parameter Fuzzing
## GET
- Say we don't have permissions to read something on a webpage
- That means there must be some key users pass in for access
	- Usually a parameter passed through **GET** or **POST** HTTP request
- `ffuf -w /opt/useful/seclists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u http://admin.academy.htb:PORT/admin/admin.php?FUZZ=key -fs xxx`
	- `?FUZZ=key`: fuzz the parameter
	- `-fs`: filter out status code xxx

### GET request after successfully fuzzing
- Say we found `'SOMETHING'` as the parameter
- In browser,
	- `http://admin.academy.htb:PORT/admin/admin.php?SOMETHING=key`
## POST
- Difference from GET: POST requests not passed with URL, cannot simply be appended after a `?` symbol
	- Instead, passed in the **data** field within the HTTP request

```c
ffuf -w /opt/useful/seclists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ 
	-u http://admin.academy.htb:PORT/admin/admin.php 
	-X POST -d 'FUZZ=key' -H 'Content-Type: application/x-www-form-urlencoded' 
	-fs xxx
```
	
- `-X` POST: send POST request	
- `-d`: pass in data field
- `-H`: tells the server the body is form data

- For this, easier to just use Burp/ZAP to replay
	- Can also ffuf with raw replay
	1. Burp/Zap -> right click a workign POST, copy to file (raw HTTP) -> req.txt
	2. Edit req.txt, put `FUZZ` where you want to inject
	3. `ffuf -request req.txt -request-proto http -w wordlist.txt:FUZZ -mc 200,302,403
- Or, manual translation from captured request
```c
ffuf -w params.txt:FUZZ \
     -u http://10.10.10.10/admin/admin.php \
     -H "Host: admin.academy.htb" \
     -H "Cookie: PHPSESSID=abcd1234" \
     -H "Referer: http://admin.academy.htb/admin/admin.php" \
     -H "Origin: http://admin.academy.htb" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -X POST -d "FUZZ=key" -mc 200,302,403
```
- If API is JSON, match body and header
```c
ffuf -w keys.txt:FUZZ \
     -u http://admin.academy.htb/api/login \
     -H "Content-Type: application/json" \
     -X POST -d '{"FUZZ":"key"}' \
     -mc 200,400,401
```

### Which headers usually matter?
- **Content-Type** — must match your `-d` format:
    - `application/x-www-form-urlencoded` → `a=b&c=d`
    - `application/json` → `{"a":"b"}`
    - `multipart/form-data` → file uploads; better done with `-request` raw replay
- **Host** — only needed if you attack by **IP** and rely on virtual hosting:
    - `-H "Host: admin.academy.htb"`
- **Cookie** — session/auth:    
    - Use `-H "Cookie: name=value"` or `-b name=value`
- **CSRF tokens / custom** — many apps require:
    - e.g., `-H "X-CSRF-Token: <token>"` **and** include the token in `-d` if the form expects it
    - If tokens rotate, use the **raw `-request` method** to avoid constant re-plumbing
- **Authorization** — Bearer/API keys:
    - `-H "Authorization: Bearer <token>"`

### Curl POST request after successfully fuzzing
- Say we found `id` as the parameter
	- `curl http://admin.academy.htb:PORT/admin/admin.php -X POST -d 'id=key' -H 'Content-Type: application/x-www-form-urlencoded'
# Value Fuzzing
- From above, we found that `'id'` is the parameter
	- But we don't know the key!
	- Can use our own wordlist to bruteforce id
		- `for i in $(seq 1 1000); do echo $i >> ids.txt; done`
	- `ffuf -w ids.txt:FUZZ -u http://admin.academy.htb:PORT/admin/admin.php -X POST -d 'id=FUZZ' -H 'Content-Type: application/x-www-form-urlencoded' -fs xxx`