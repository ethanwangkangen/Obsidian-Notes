
## The 3 SSH forwarding modes (anchor this)

| Flag | Name               | Who opens the port? | Typical use                   |
| ---- | ------------------ | ------------------- | ----------------------------- |
| `-L` | Local forwarding   | Your machine        | Access internal services      |
| `-D` | Dynamic forwarding | Your machine        | SOCKS proxy / pivot           |
| `-R` | Remote forwarding  | Remote machine      | Expose your service to target |

# (Static) Local Port forwarding with SSH
- Target port and host is known.
- local port -> remote host -> remote port
- One destination, one host, one service
- `ssh -L <local_port>:<remote_host>:<remote_port>`
	- Any traffic sent to `localhost:1234` on my computer is securely forwarded through SSH to `remotehost:remote port`
- Eg. if that `remotehost:remote port` is a MySQL service,
	- Can access it with `mysql -h 127.0.0.1 -P 1234 -u <db_user> -p`
	- Even through MySQL running only on remote server, feels like it's running on local machine
	- If `nmap -p localhost`, will see the mysql service
- Use case
	- Want to utilise a remote exploit on the MySQL service

# Dynamic Port Forwarding
- What if you don't know which hosts/servies exist?
- Instead of `forward THIS port to THAT port`, is `forward ANY connection I ask for`
- SSH Tunneling over SOCKS proxy
- Scenario
	- Have target server `WEB01` that has access to internal network
	- We want to run `nmap` on the internal network, but can only access it through the target server
- First, start dynamic forwarding 
	- `ssh -D 9050 ubuntu@WEB01`
	- `-D`: enable dynamic port forwarding
	- This implements a **SOCKS5** server that listens on `127.0.0.1:9050`
- SOCKS
	- SOCKs is the **protocol** that specifies how a client asks a proxy to create and manage a network connection on its behalf
	- SOCKS server
		- The program that actually opens the network connection to target destination
		- Started through the -D command from SSH (above)
		- In this case, it listens on `localhost:9050`
		- But the actual outbound connections to the internal network are made by `WEB01`
		- For each request
			- It forwards it to the SSH daemon on WEB01
			- WEB01 executes `connect(IP, port)`
	- SOCKS client
		- This is the program that wants to reach remote destination but cannot
			- Eg. nmap wrapped with ProxyChains, curl --socks5, metasploit configured with proxyu
		- Connects to the SOCKS server
		- Sends request, please connect to IP x, port Y
- ProxyChains
	- We need to force the tool (in this case, `nmap`) to send to the SOCKS listener on `localhost:9050`instead of directly trying the internal network we don't have access to.
	- First configure proxychain config file
		- `vim /etc/proxychains.conf`
		- add the line `socks5 127.0.0.1 9050`
- Finally run the tool with proxychain
	- `proxychains nmap -v -sT -Pn 172.16.5.1-200`

To summarise
1. `ssh -D 9050 ubuntu@WEB01`
2. `proxychains nmap -v -sT -Pn 172.16.5.1-200` (or whatever tool you want to forward through the pivot)
	- Take note: this is run from a separate terminal, not the one with the open SSH connection


Final stack
```
Application
  ↓ (connect())
ProxyChains (optional)
  ↓ (SOCKS protocol)
SOCKS server (ssh -D)
  ↓ (SSH tunnel)
Pivot host
  ↓
Internal network
```

![[22.png]]

# Using Metasploit with Proxychains
- Can also open Metasploit with proxychains and send all associated traffic through the proxy we have just established
	- `proxychains msf console`
- eg. Use `rdp_scanner` to see if port on an internal host is open (through the victim server pivot)

## xfreerdp with proxychains
- `proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123`


