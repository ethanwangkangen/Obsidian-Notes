# SSH for Windows: Plink.EXE
(Kiv)

# SSH Pivoting with sshuttle
- Tool which **removes need to configure proxychains**
- Similar to a VPN
- However, only works for pivoting over SSH
	- No options for pivoting over TOR or HTTPS proxy servers
- Most comparable with Meterpreter + SOCKS + autoroute
	- Both give dynamic destination selection
	- Difference: (see below)
- Not like SSH -L, since that is service-level and not network level

- Install
	- `sudo apt-get install sshuttle`
- Connect to remote machine
	- `-r` to connect to pivot (will require ssh password)
	- Then include the network/IP we want to route through the pivot host (ie. the internal network/machine)
	- `sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0/23 -v `
		- sshuttle installs iptables (or nftables) rules to **intercept traffic destined for 172.16.5.0/23 and redirect it to sshuttle’s user‑space process**, which then tunnels it over SSH.
		- This also causes sshuttle to launch a Python helper (via SSH) **on the pivot machine**, run via SSH. This helper receives the encapsulated packets, decapsulates them and sends them onward to internal network
- `sudo nmap -v -A -sT -p3389 172.16.5.19 -Pn`
	- Packets are intercepted by sshuttle, sent to the pivot (via SSH) with instructions to send to the internal network.


| Feature               | SOCKS                                        | sshuttle                                                       |
| --------------------- | -------------------------------------------- | -------------------------------------------------------------- |
| Layer                 | Application (TCP stream proxy)               | Network / IP routing                                           |
| Tool aware?           | Yes (tool must support SOCKS or proxychains) | No (tools think they’re talking directly to the internal host) |
| Ports                 | Chosen at runtime                            | Chosen by application (any)                                    |
| Destination           | Chosen at runtime                            | Chosen at runtime                                              |
| Protocol              | TCP only                                     | Mostly TCP, limited UDP                                        |
| Setup                 | Meterpreter or SSH + SOCKS                   | SSH only, installs iptables rules / routing                    |

## Comparing sshuttle with SOCKS
First: what does “layer” even mean here?
- It means where the decision “where should this traffic go?” is made.

SOCKS = application‑layer decision
- What this actually means
	- With SOCKS:
	- Your tool explicitly chooses to use the proxy
- Example:
	- `proxychains nmap 172.16.5.19 -p 445
	- nmap knows it is using a proxy
	- nmap does NOT try to connect directly to 172.16.5.19
	- Instead, it connects to:
		- `127.0.0.1:9050
	- Inside that SOCKS connection, nmap tells the proxy:
		- "Please connect to 172.16.5.19 on port 445"
	- SOCKS proxy (Meterpreter / SSH) makes that connection on behalf of nmap

Key idea:
The application is aware of the proxy and participates in the decision.
That’s why SOCKS is called application‑layer.

Why proxychains exists
- Because many tools:
- Don’t natively speak SOCKS

So proxychains:
- Hijacks libc connect() calls
- Forces the application to talk to SOCKS anyway
- Still application‑level — just forced.

sshuttle = network / IP routing decision
- What this actually means
	- With sshuttle:
	- Your application does nothing special at all
- Example:
	- nmap 172.16.5.19 -p 445
- Here’s what happens:
	- nmap asks the OS:
	- “Please send a TCP packet to 172.16.5.19:445”

The OS checks the routing rules
sshuttle has added rules saying:
“Any traffic to 172.16.0.0/16 goes via this SSH tunnel”

The OS sends the packet to sshuttle
sshuttle forwards it over SSH
Pivot sends it to the internal host
Key idea:

The OS routing layer decides — not the application.
That’s why sshuttle feels “transparent”.