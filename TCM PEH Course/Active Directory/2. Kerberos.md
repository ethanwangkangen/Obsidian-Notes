
High level Summary
- Kerberos is a ticket-base authentication protocol
- Trusted authority (Key Distribution Centre, KDC) vouches for identites by issuing tickets encrypted with target's service key
- Clients get a Ticket-Granting Ticket (TGT) from KDC
	- Use that TGT to request service tickets
	- Tickets contain a session key used to authenticate to the service

# Core concepts and actors
- Principal — an identity (user or service), written user@REALM or service/hostname@REALM.

- Realm — administrative domain (in AD, typically the DNS domain CORP.LOCAL).

- KDC (Key Distribution Centre) — authoritative server for a realm. Contains two logical services:
	- AS (Authentication Service) — issues TGTs.
	- TGS (Ticket Granting Service) — issues service tickets when presented a valid TGT.
		- In Active Directory the KDC/TGS runs on Domain Controllers; the krbtgt account stores the KDC’s long-term key.

- TGT (Ticket Granting Ticket) — a ticket encrypted with the KDC’s (krbtgt) key; contains a session key the client will use to talk to the TGS.

- Service Ticket — a ticket encrypted with the service principal’s key (the key of the account corresponding to the SPN, e.g. cifs/fileserver.corp.local), so only the intended service can decrypt it.

- Session key — ephemeral symmetric key inside tickets used for client↔TGS or client↔service authenticators.

- Authenticator — a small structure encrypted with the session key (includes client timestamp, optional sequence number) proving freshness and preventing replay.

- SPN (Service Principal Name) — string used to identify a service, e.g. cifs/fileserver.corp.local. Kerberos tickets are issued for SPNs.

- PAC (Privilege Attribute Certificate) — Microsoft extension inside the ticket carrying user SIDs, group membership and authorisation data; it’s signed by the KDC.

- Etype (encryption type) — algorithm used: historically DES/RC4, modern AD uses AES128/AES256 (AES-CTS-HMAC-SHA1-96 etc.).

- krbtgt account — special AD account whose key is used by the KDC to encrypt TGTs; compromise allows forging TGTs (“golden ticket”).

# Message flow

Notation
- `{…}_K` means “data encrypted with key K”.
- `Kc` = client long-term key (derived from password).
	- both client and KDC know this
- `K_tgs` = KDC/krbtgt key.
	- client never gets this
- `K_c_tgs` = **session key** inside TGT between client and TGS.
	- client decrypts this at stage 2
- `K_s` = service principal key (stored with the service account).
- `auth{…}_K` = authenticator encrypted with key K.

### 1) AS-REQ (Client → KDC/AS)

Client requests a TGT. If the KDC requires pre-authentication (default in AD), client includes **preauth** data:

`AS-REQ:`
  `client_principal (C)` (client identity, eg. alice/admin@EXAMPLE.COM)
  `realm` (the domain, eg. EXAMPLE.COM)
  `nonce`
  `etype_preference_list`
  `(PA-ENC-TIMESTAMP encrypted with Kc)  <- only if KDC requires preauth`

**Pre-auth (PA-ENC-TIMESTAMP)**: client encrypts a timestamp with `Kc` (derived from the user password). That proves possession of the password and prevents offline brute-forcing AS-REP.

### 2) AS-REP (KDC/AS → Client)

If preauth checks out, KDC returns:

`AS-REP:`
  `{ ticket_tgt }_{K_tgs}     // encrypted with krbtgt key — only KDC/TGS can read`
  `{ enc_part }_{Kc}           // includes session key K_c_tgs and ticket flags, lifetimes`
  
`enc_part` is encrypted with the client's key `Kc`. Only the legitimate client (who holds the password) can decrypt it to obtain `K_c_tgs`.
- Idea: KDC sends the tgt encrypted with K_tgs, as well as the Kc_tgs (session key) encrypted with K_c for the client to retrieve

The TGT is not (and cannot be) decrypted by the client. 

### 3) TGS-REQ (Client → KDC/TGS)

Client now wants a service ticket for SPN `s@REALM`. It sends:

`TGS-REQ:`
  `{ ticket_tgt }_{K_tgs}    // the TGT from AS-REP`
  `authenticator = { C, timestamp, subkey? }_{K_c_tgs}`
  `sname (the requested service principal: e.g. cifs/fileserver.corp.local)`
  `requested etype, options (forwardable, proxiable, renewable etc.)`

The `authenticator` proves client possession of `K_c_tgs` and freshness.

- The TGT is just forwarded by the client. 
- The authenticator is encrypted with the session key (retrieved by the client previously)
	- Idea is that tickets alone prove authentication, but can be replayed by attacker. Authenticator adds freshness (timestamp), changes with every request. 

### 4) TGS-REP (KDC/TGS → Client)

KDC verifies TGT + authenticator, then issues a service ticket:

`TGS-REP:`
  `{ ticket_s }_{K_s}           // ticket encrypted with service key (K_s)`
  `{ enc_part }_{K_c_tgs}       // includes K_c_s (session key for client↔service)`

- `ticket_s` holds `K_c_s`, client principal, times, ticket flags, and PAC (in AD).
	- again, this is just forwarded by client to the service and is not decrypted
	- only the service holding `K_s` can decrypt `ticket_s` and learn the session key
- similar to just now, the client decodes the encoded part to retrieve the session key for the service, ie. K_c_s

### 5) AP-REQ (Client → Service) — client presents ticket

Client sends to the service:

`AP-REQ:`
  `ticket = { ticket_s }_{K_s}`
  `authenticator = { C, timestamp, checksum }_{K_c_s}`
  
- Service decrypts `ticket_s` with `K_s`, gets `K_c_s`, then decrypts the authenticator to verify timestamp, client principal and freshness.
    
- If the authenticator verifies, the client is authenticated.

### 6) AP-REP (Service → Client, optional)

For mutual authentication, the service may return:

`AP-REP:`
  `{ timestamp+1 }_{K_c_s}`

This proves to the client that the server actually holds `K_s`.

![[Pasted image 20250822121540.png]]
# What's the point of the TGT?
- Security
	- Client proves its identity once to the AS
	- KDC returns a TGT encrypted with the KDC/TGT key (krbtgt) which the client cannot read
	- TGT now acts like a capability token, **proves** to the TGS that client was authenticated **without exposing password again**
- Efficiency
	- Client can request service tickets from the TGS **multiple times** using the same TGT, no need to talk to AS every time