# Variables 
- A variable is a **label** that
	- refers to a specific memory location
	- has a type that tells compiler how to interpret the bytes at that location.
	- ie. a variable label is just an alias for an address, that does not change (throughout lifecycle of a program)
- So for example,
	- `char s[]= "hello"`
		- s is a variable that refers to the memory location 0x1000, which is the location of the first char of the string.

- For local variables, the memory address assigned to it does not change throughout.

## Types of variables

Basic types

| type   | size (bytes) | value range                                       |
| ------ | ------------ | ------------------------------------------------- |
| int    | 4            | -(2^32)/2  to 2^32-1                              |
| char   | 1            | -128 to 127 (signed), 0 to 255 (2^8-1) (unsigned) |
| float  | 4            |                                                   |
| double | 8            |                                                   |
| void   | 0            |                                                   |
|        |              |                                                   |

Derived types
- Array
	- `int nums[5];`
- Pointer
	- `int *p;`
- Structure
- Union
- Function

Enumeration type
- `enum Color { RED, GREEN, BLUE };`
- by default, RED=0, GREEN=1 etc.
- stored as int internally

Void type
- void function return type: indicates the function returns nothing
- void pointer
	- generic pointer to any data type
	- cannot be dereferenced directly
	- must be cast to correct type first
	- eg.
		- `void *ptr;`
		- `int x = 5;`
		- `ptr = &x;`
		- `printf("%d", *(int *)ptr);`
			- ptr is still of type void *
			- need to cast it to int * first
			- then deference it.


# Pointers 
- A pointer is a **variable** that stores the address of another variable.
	- `int x = 5`
	- `int *p = &x;` 
		- p is a variable of type (int \*), which is a variable that stores an address of an integer variable.

eg. 
Address       Value                   Description
--------    ----------    --------------------------
0x7ffeefb8  0x7ffeefc0        ← p (holds address of x)
0x7ffeefc0  0x00000005     ← x (value: 5)

The above depicts 32-bit architecture.
- Memory is byte addressable. Each memory location stores a byte
- Addresses are **32-bit** ie. 4 bytes long
- So **pointers are 4 bytes long, and take up 4 memory addresses to store**
	- The shown address above is just the starting value of the storage.
- So 0x7ffeefc0 will span 4 consecutive memory addresses.
- If little endian,
	- c0 stored in 0x7ffeefb8 
	- ef stored in 0x7ffeefb9
	- fe stored in 0x7ffeefba
	- 7f stores in 0x7ffeefbb

For 64-bit architecture,
- Addresses are 64-bit ie. 8 bytes long.
- So **pointers are 8 bytes long, and take up 8 memory addresses to store**

## Pointer Arithmetic
- When a pointer is incremented, it actually is incremented by the size of whatever object it stores.
- This ends up being what happens under the hood for Array indexing
- eg. 

```c
int arr[5] = {10, 20, 30, 40, 50};
int *ptr = arr;

printf("%d\n", *ptr);    // Outputs 10
ptr++;                   // Moves the pointer to the next integer in memory
printf("%d\n", *ptr);    // Outputs 20
```

- ptr initially stores the address of arr\[0]
- when **ptr++**, this is actually
	- **ptr = ptr + sizeof(int) bytes**
- so ptr now stores that address of arr\[1]

- in essence,
	- `a[i]` is the same as `*(a+i)`
- because a is a pointer to the first element, and adding `i` advances by `i * sizeof(element)` bytes