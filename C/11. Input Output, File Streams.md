# File Pointers

```c
FILE *fp;
```

This is a pointer to a FILE object, defined in standard I/O library <stdio.h>.

## Opening a file
```c
fp = fopen("example,txt", r);
```
- r: read
- w: write (creates new file or truncates existing)
- a: append

```c
if (fp == NULL) {
  perror("Error opening file");
  return 1;
}
```

## Reading/writing files
```c
// Writing
fprintf(fp, "Hi\n");

// Reading
char buffer[100];
fgets(buffer, 100, fp);
```

| Function                         | Purpose                           |
| -------------------------------- | --------------------------------- |
| `fopen()`                        | Open file and return FILE pointer |
| `fclose()`                       | Close the file                    |
| `fgetc()`, `fgets()`             | Read characters/lines             |
| `fputc()`, `fputs()`             | Write characters/lines            |
| `fread()`, `fwrite()`            | Binary I/O                        |
| `fseek()`, `ftell()`, `rewind()` | Navigate file                     |
| `fprintf()`, `fscanf()`          | Formatted I/O                     |
|                                  |                                   |
|                                  |                                   |

# Method list
```c
FILE *fopen(const char *filename, const char *mode);  
// Opens a file and returns a FILE pointer

int fclose(FILE *stream);  
// Closes an open file

int fgetc(FILE *stream);  
// Reads a single character from file

int fputc(int c, FILE *stream);  
// Writes a single character to file

char *fgets(char *str, int n, FILE *stream);  
// Reads a string (line) from file, stores in str
// Reads up to n-1 characters, stops when it reads a \n or has read n-1 char or hits EOF. 
// Adds \0at the end

int fputs(const char *str, FILE *stream);  
// Writes a string to file (no newline added)

size_t fread(void *ptr, size_t size, size_t count, FILE *stream);  
// Reads binary data from file
// ptr = where to store data
// size = size of each item, eg. sizeof(int)
// count = num of items

size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream); 
// Writes binary data to file

int fprintf(FILE *stream, const char *format, ...);  
// Writes formatted output to file

int fscanf(FILE *stream, const char *format, ...);  
// Reads formatted input from file

int feof(FILE *stream);  
// Returns non-zero if end of file is reached

int ferror(FILE *stream);  
// Returns non-zero if a file error occurred

void clearerr(FILE *stream);  
// Clears the EOF and error indicators

int fflush(FILE *stream);  
// Flushes the output buffer to the file

int fseek(FILE *stream, long offset, int origin);  
// Moves file pointer to a specific location

long ftell(FILE *stream);  
// Returns the current position in the file

void rewind(FILE *stream);  
// Resets file position to beginning

int setvbuf(FILE *stream, char *buffer, int mode, size_t size);  
// Sets buffering mode for a file stream
// buffer =
// _IOFBF : full buffering
// _IOLBF : line buffering
// _IONBG : no buffering

void setbuf(FILE *stream, char *buffer);  
// Simpler version of setvbuf()

```

# Related I/O functions
- Essentially, the functions from above but without the "f" prefix, taken/sent to stdin/out
```c
int printf(const char *format, ...);  
// Prints formatted output to stdout

int sprintf(char *str, const char *format, ...);  
// Writes formatted output to a string

int snprintf(char *str, size_t size, const char *format, ...);  
// Writes formatted output to string with size limit

int scanf(const char *format, ...);  
// Reads formatted input from stdin

int sscanf(const char *str, const char *format, ...);  
// Reads formatted input from string

int puts(const char *str);  
// Writes a string followed by a newline to stdout

int putchar(int c);  
// Writes a character to stdout

int getchar(void);  
// Reads a character from stdin

char *gets(char *str);  // (⚠️ unsafe; use fgets instead)  
// Reads a line from stdin

```

# Standard Streams
- stdin, stdout, stderr are predefined streams.
- they correspond to the following file descriptors:
	- stdin: 0
	- stdout: 1
	- stderr: 2
- eg.
	- ./a.out > out.txt //stdout goes to file
	- ./a.out 2> error.log // stderror goes to file
	- ./a.out < input.txt // stdin comes from file
- Can use functions like fgets(), fprintf(), or fread() with them just like any FILE \*.

# Buffering
- Almost all file I/O including stdin and stdout is buffered

| Stream               | Buffered? | Type of Buffering (Default)                                  |
| -------------------- | --------- | ------------------------------------------------------------ |
| `stdout` to terminal | ✅ Yes     | **Line-buffered** (flushes on `\n`)                          |
| `stdout` to file     | ✅ Yes     | **Fully buffered** (flushes when full or on `fclose/fflush`) |
| `stdin` (keyboard)   | ✅ Yes     | **Line-buffered** (reads after Enter key)                    |
| `stderr`             | ✅ Yes     | **Unbuffered** (writes immediately)                          |
| `FILE *fp` to file   | ✅ Yes     | **Fully buffered**                                           |


eg. writing to file: fully buffered
```c
FILE *fp = fopen("output.txt", "w");
fprintf(fp, "Hello, file!");
// Still in buffer – not yet written to disk!
fclose(fp);  // flushes the buffer to the file
```

eg. writing to terminal (line buffered)
```c
printf("Enter name: ");  // Without newline, might not appear yet
fflush(stdout);          // Force flush now so user sees it
```


- Buffering applies for both reading from and writing to files
	- But don't really need to concern with read buffer as much
		- Can see the effects: eg. reading from stdin.
		- fgets(stdin, ...) or scanf(...), input is buffered until user presses \n

# fgets
- say i'm writing from stdin to a buffer, with fgets.

```c
char buff[50];
fgets(buff, sizeof(buff), stdin)

// Then compare with password
char *pass = "Password";

if (strcmp (buff, pass) == 0) {
	puts("Success!");
}
```

But because you type in Password\n,
- the newline is included in buff 
- so buff looks like
	- ['P', .... 'd', '\n', '\0']

and strcmp reads until '\0', so
- 'Password\n' =/= 'Password'

Solution
- add '\0' (the terminator) to the input.