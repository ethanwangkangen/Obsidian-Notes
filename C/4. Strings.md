A string is 
- an array of char
	- `char s[]= "hello"`

 Stack:
Address     Value      Meaning      Label
--------    --------   ---------------------
0x1000      'h'        s\[0]                s
0x1001      'e'         s\[1]
0x1002      'l'         s\[2]
0x1003      'l'         s\[3]
0x1004      'o'        s\[4]
0x1005      '\0'       s\[5] (null terminator)

s = 0x1000 (fixed, array name = address of first element)

s is a variable. [[2. Variables, Pointers]]


## String functions

**Copying**
`char dest[20];`
`strcpy(dest, "hello"); # Note: allows overflow!!`

To avoid overflow, use strncpy.

`strncpy(dest, "hello", sizeof(dest) -1);`
`dest[sizeof(dest) - 1] = '\0';  // always null-terminate manually`

**Concatenating**
`char a[20] = "hi ";`
`char b[] = "there";`
`strcat(a, b);  // a becomes "hi there"` 
`// Use strncat to avoid overflow.`
`strcat(a, b, 6); # remember to add the null terminator`

**Comparing**
`strcmp("abc", "abd");    // returns < 0`

**Length**
`strlen("hello");  // returns 5 (not including '\0')`

**Modifying**
`char s[] = "hello";`
`s[0] = 'H';       // Now s is "Hello"`
`s[3] = '\0';      // Now s is "Hel"`

**scanf**
`char name[100];`
`scanf("%99s", name);  // limit to avoid overflow`

`int scanf(const char *format, ...);`
- reads from input stream (stdin), attempts to interpret and convet it according to specified format string
- [[5. Format specifiers]]


**fgets**
`char name [100];`
`fgets(name, sizeof(name), stdin);`
- sizeof(name) gives total size in bytes of the name array, which is 100 bytes since 1 char takes up 1 byte

`char *fgets(char *str, int n, FILE *stream);`
- str: pointer to the char array (buffer) to the store the string
- n: max number of char to read, including null terminator
- stream: pointer to the FILE object from which to read
	- for standard input (keyboard), this is usually stdin

- reads character from the specified stream until
	- newline character is encountered, after which newline char is included in the buffer
	- OR n-1 char read
	- OR end-of-file read
- after reading, always appends null terminator to str buffer
- returns the str on success
	- which is of type char \*

**strstr - *finding substring***
`char *pos = strstr("hello world", "world");`
`if (pos != NULL) {`
    `printf("Found at index %ld\n", pos - "hello world");`
`}`

**strtok - *tokenise string***
`char str[] = "one,two,three";`
`char *token = strtok(str, ",");`
`while (token != NULL) {`
    `printf("%s\n", token);`
    `token = strtok(NULL, ",");`
`}`


## Implementations
```c
// char array (buffer)
char str[6]; // Memory in stack (if within function)
strcpy(str, "hello");

// OR
char str[] = "hello"; // size inferred as 6 (include \0)

//NOT ALLOWED 
char str[]; //ERROR! : must define size of array

#------------------------------------------------------#

// Dynamic allocation
char *str = malloc(50); // Memory in heap. Writeable
strcpy(str, "hello");
free(str);

#------------------------------------------------------#

// Pointer to string literal
char *str = "hello"; // Stored in read-only memory. Not writeable
```

**Implementations**
- **char buffer (array)**
	- stored in **stack** (assuming within function)
- **dynamic allocation**
	- memory allocated in **heap**
	- can be rewritten, resized etc.
- **pointer to string literal**
	-  "hello" is now a string literal that is stored in the **text segment** of the [[6. Memory Segments]]
	- "hello" is stored in **read-only** memory 
	- str is just a char pointer that stores the address of "hello" (or to be specific, "h")
	- since read-only memory, can no longer be modified
	