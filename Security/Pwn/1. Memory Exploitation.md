2 broad types
- Temporal
- Spatial

# Stack-based attacks and other spatial attacks

## Stack-based buffer overflow (spatial)

```c
void vulnerable(char* input) {
    char buf[8];
    strcpy(buf, input); // no bounds checking!
}
```

For the stack layout, see [[2. Stack layout]]

Basic stack:

| Higher address    |                                          |                                                                                |
| ----------------- | ---------------------------------------- | ------------------------------------------------------------------------------ |
|                   | (optional) arguments passed to fn        | *for 64-bit architecture, only after firs 6 args. First 6 passed via registers |
|                   | **Return Address**                       |                                                                                |
|                   | Old base pointer                         | Base pointer                                                                   |
|                   | **... Local variables (buffer is here)** |                                                                                |
|                   |                                          | Stack pointer                                                                  |
| **Lower address** |                                          | <br>                                                                           |
|                   |                                          |                                                                                |

Important points
- Stack grows downwards. 
- When function calls another function, new stack frame is placed BELOW
	- Arguments for callee (new function) are pushed (added below)
	- Call instruction -> return address pushed, which points back to caller (old function)
	- Callee prologue
		- `push ebp` -> save caller's EBP
		- `mov ebp, esp` -> set base pointer for callee frame
		- `sub esp, N` -> allocate callee locals



**New stack:**

| Higher address        |                                          |                                                                                |
| --------------------- | ---------------------------------------- | ------------------------------------------------------------------------------ |
|                       | (optional) arguments passed to fn        | *for 64-bit architecture, only after firs 6 args. First 6 passed via registers |
|                       | **Return Address**                       |                                                                                |
|                       | Old base pointer                         | ~~Base pointer~~ (caller's BP)                                                 |
|                       | **... Local variables (buffer is here)** |                                                                                |
|                       |                                          | ~~Stack pointer~~ (moves down before becoming new BP)                          |
| New frame starts here | Arguments for new function               |                                                                                |
|                       | Return Address                           |                                                                                |
|                       | Caller's base pointer                    | Base pointer                                                                   |
|                       | Local variables                          | <br>                                                                           |
| **Lower address**     |                                          | Stack pointer                                                                  |

- Idea is
	- Have a buffer, in this case buf
	- Have a function that doesn't do bounds check.
	- Eventually want to overwrite the return address of the function that contains the buffer in its scope
		- ie. For return address of the stack frame of that function

## ret2libc

We know how to overflow and modify the Return Address (RIP).
Now, overwrite it to make a system call.

| Higher address    |                         |                |               |
| ----------------- | ----------------------- | -------------- | ------------- |
|                   |                         | <- &'bin/sh'   |               |
|                   |                         | <- Fake return |               |
|                   | **Return Address**      | <- &system     |               |
|                   | Old base pointer        |                | Base pointer  |
|                   | **... Local variables** |                |               |
|                   |                         |                | Stack pointer |
| **Lower address** |                         |                | <br>          |

Explanation:
- What we did was essentially simulate the system() function as a CALLEE stack to the vuln() function
	- ie. set up a **fake stack frame BEFORE** vuln()'s stack frame
	- essentially, pretending like system() is the caller of vuln(), such that when vuln, returns, system() executes, and has the correct stack frame set up for itself
- Once the vuln() returns, CPU pops the return address, instruction pointer jumps to system()



## to include: format string vuln, other stuff from 3235 lecture 2
## bad casting

C++: Class Subtyping
```c
class Base{
  // members...
  // member function
}

class Derived : public Base {
	// members...
	// member function
}

Derived* d = new Derived();
```

How memory works:
- The layout of the derived object contains the base object
- \[\[Base object] Derived object]
	- d points to the start of the Base object
- because every variable/method in the Base class is accessble in Derived

C++ implementation
- Upcasting with Single inheritance
	- Upcasting always safe in C++, ie. can cast Derived (child) class to Base (parent) class, ie D to B

```c
Derived* d = new Derived()

// Implicit cast
Base* b1 = (Base *) &d;

// Explicit caast
Base* b2 = static_cast<Base*> (&d);
```

- now d, b1, b2 all pointing to the start of the Base object in memory

Multiple inheritance
```c
class B1 {...}; class B2 {...};
class Derived: public B1, public B2 {...}; // Derived inherits from both B1 and B2

Derived* d = new Derived();

// Implicit cast
B1* b1 = (B1 *)&d;
B2* b2 = (B2 *)&d; // Pointer moves! from start of d to b2. Should not have anything from b1.

// Explicit cast
B2* h = static_cast<B2*> (&d);
```

\[\[B1]\[B2] Derived object]
- b1, d point to start of b1
- b2, h point to start of b2

Downcasting also allowed.
```c
class B1 {...}; class B2 {...};
class Derived: public B1, public B2 {...}; // Derived inherits from both B1 and B2

Derived* d = new Derived();

int foo (B2* b) {
	Derived* d = static_cast <Derived*>(b); // downcast
}
```

\[\[B1]\[B2] Derived object]
- pointer goes from start of B2 to start of B1.

This is not always safe!
- it's assuming that b did in fact point to a Derived object, but may not be the case.
- ie. it's ONLY safe if i use foo() on an actual Derived object

**Unsafe downcast example**
```c
class Base {int x};
class Derived : public Base {int y};

int foo (B2* b) { // downcast
	Derived* d = static_cast <Derived*>(b); 
}
int main() {
	Base *b = new Base();
	foo(b); // b is now of type Derived
	d -> y = 0; // changes memory that it shouldn't have access too
}
```

b is only a base object. 
- it doesn't actually have a y allocation (not in scope), but program allows it to modify memory below x.

**Worse, badcasting with multiple inheritance**
```c

class B1{...}, class B2 {int y};
class Derived: public B1, public B2 {...}

B1* = new B1();

// Unsafe downcast
Derived* d = (Derived*) b1;
B2* b2 = (B2*)&d;

B2 -> y = 0
```

\[\[B1]\[B2] Derived object]
- Originally, just have a B1 object. No memory allocated for B2 etc.
- the **b2 pointer moves down** from B1 to B2. (BUT THERE'S ACTUALLY NO MEMORY ALLOCATED THERE)
- so again, b2-> writes to some unknown memory that should not be allowed

So the key ideas:
- single inheritance: downcasting can be dangerous, may allow access to regions of memory that it should not have
- multiple inheritance: base pointer can move up/down due to unsafe downcasting, again allowing memory writing to unsafe places

