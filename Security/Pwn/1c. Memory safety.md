
Goals
- Create memory pointers via permitted operations
	- malloc(), p = &q
- Only access memory allocated to the pointer
	- Spatially -> within allocated range
	- Temporally -> while the memory is in liftetime
- All 'objects' spatially disjoint at all times

Enforcing these:
- Checks, via compilation, or rewriting the binary
- Insert metadatea and inline monitors (checkers)
	- Assume metadata only accessed by monitors

Spatial Safety
- Associate bounds with each pointer (or object)
	- How large the address space, associate with metadata
- Check each pointer (or object) before access
	- But remember that pointers can be incremented, type casted..
- Where to keep these metadata?
	- within fat pointers (next to the pointer)
	- within reference object (next to the object)
- Assume metadata can't be corrupted, and program doesn't affect it. Compiler needs to ensure that the metadata it adds does not let the program modify it

Enforcement
- Static and Dynamic (dynamic encompasses static)
	- static not good enough, might have false positives, don't know how program runs..
- Try to do as much statically, then the rest do dynamic. Runtime checks incur cost so try to minimise.

# Dynamic Spatial Memory Safety: Fat pointers

Fat pointers
- Keep the bounds next to the pointer
- So \[pointer]\[start, end]

```c
ptr = malloc(size());
ptr_bound = ptr+size;
```
- No difference for stack or heap variable.
- Then, each dereference checks pointer within \[start, end]
	- dereference -> reading or writing
- Do *no checks* on pointer arithmetic or unsafe type casts
	- Because the check will be delayed until dereference
	- Just copy bounds metadata form old to new pointer
	- The dereference check will catch the bad cast
- Diff size-type pointers have diff bounds
	- eg. spatial overlap, but still dif bounds. eg.
```c
typedef struct {..., char str[8], ...} node;
ptr = &node.str[2];
ptr_base = &node.str[0];
ptr_bound = &node.str[8];

// ptr for the string can't access the rest of struct
```

- why bad casting no change:
	- see [[1. Memory Exploitation]]., bad casting
	- the bounds are set, then when typecasting happends, bounds do not change

- What happens for safe casting? ie. upcasting from Derived to Base
	- Bounds actually are reduced
	- Compiler can choose to reduce the bound
	- But maybe don't. If just keep the same bound, allow mem-safe downcasting later on.

Summary of fat pointers
- Complete spatial safety
- Code compiled for normal pointers will crash when passed fat pointers

# Temporal Safety

1. Track creation and destruction of pointers
2. Ensure that when de-allocated pointers are not accessed
	- idea 1: when free pointer, set it to NULL
		- doesnt work. What if there's another pointer pointing to the object? ie. aliasing
	- CETs: Lock and Key
		- lock and key values match if and only if memory object is temporally safe to access via this pointer
		- same region of memory used by diff objects over time (view this as a house)
		- allocate memory to object -> give a key
		- allocate -> check key
		- deallocate -> change lock. all the other keys dont work anymore

CETs
- associate a (key, lock) pair with each pointer
![[Pasted image 20250909083837.png]]
```c
ptr = malloc(size);
ptr_key = next key++; // key has to have unique value for each obj allocated
*(ptr_lock_addr) = ptr_key; 
freeable_ptr_map.insert(ptr_key, ptr);
```

- If creating a pointer from another pointer, just inherit the (key,lock) value
- On dereference, check if the pointer's key matches it's lock
	- `ptr_key == *ptr_lock_addr`
- On deallocation, change the lock value
	- `*ptr_lock_addr = something else`
	- ptr_key no longer matches with it

Cost
- Runtime checks can be costly


# Smart pointers
- Behaves like a pointer but automatically manage the lifetime of the object it points to
- 3 types
	- Unique ptr, only one unique ptr can own a resource at a time
	- Shared ptr, reference counter is used, since multiple of these can share the same resource. When counter hits 0, resource freed
	- Weak ptr
- Resource lifetime tied to object lifetime
	- When the smart pointer goes out of scope, the destructor is automatically called, freeing the resource
		- Memory returned to OS for reallocation, ie free.
		- The pointer itself now set to NULL ptr
		- No more risk of double free (free not handled by programmer), and programmer can no longer use ptr to access that region of memory (unlike normal ptr and delete)
	- No need to manually delete

- Smart pointer acts as a wrapper
